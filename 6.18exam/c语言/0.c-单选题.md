## 单选题

### 1
在C++程序中由 new分配的动态内存空间必须通过【    】运算符释放。

A. list
B. delete
C. renew
D. drop

答案：B

### 2
由类模板实例化得到的类称为【    】

A. 对象
B. 基类
C. 模板类
D. 模板函数

答案：C

### 3
下列关于重载流插入运算符和流提取运算符的说法中，错误的是【    】

A. 右移运算符">>"被称为流提取运算符
B. 左移运算符"<"被称为流插入运算符
C. 程序员可以对流插入运算符和流提取运算符进行重载
D. 流是标准类库，用户程序只能修改不能继承

答案：D

### 4
C++中要实现动态联编，调用虚函数时必须使用【    】

A. 类名
B. 派生类指针
C. 对象名
D. 基类指针

答案：D

### 5
对于在不同的作用域声明的标识符，可见性的一般原则不包括【    】

A. 在没有互相包含关系的不同作用域中声明的同名标识符，互不影响
B. 标识符要引用在前，声明在后符
C. 在同一个作用域中，不能声明同名的标识
D. 如果存在两个或多个具有包含关系的作用域，外层声明了一个标识符，而内层没有再次声明同名标识符，那么外层标识符在内层仍然可见

答案：B

### 6
使用setw()时需要包含头文件【    】

A. iostream.h
B. fstream.h
C. stdlib.h
D. iomanip.h

答案：D

### 7
类 ofstream 和类 ifstream 是从类【    】派生而来的。

A. iomanip
B. fstream
C. iostream
D. istream

答案：D

### 8
下列关于派生类构造函数执行的一般次序的说法中，错误的是【    】

A. 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）
B. 对派生类新增的成员变量初始化，调用顺序按照它们在类中声明的顺序
C. 基类构造函数的调用和各个成员变量的初始化顺序与构造函数初始化列表中基类名.对象名的次序有关
D. 基类构造函数的调用和各个成员变量的初始化顺序与构造函数初始化列表中基类名.对象名的次序无关

答案：C

### 9
作用域分为全局域和局部域两类，下列属于全局域的是【    】

A. 块作用域
B. 函数作用域
C. 文件作用域
D. 类作用域

答案：C

### 10
当一个类的某个函数被说明为virtual时，在该类的所有派生类中的同原型函数【    】

A. 都是虚函数
B. 只有被重新说明时才是虚函数
C. 只有被重新说明为 virtual 时才是虚函数
D. 都不是虚函数

答案：A

### 11
【    】指能够在Windows的"记事本"程序中打开，且能够识别出其中文字的文件。

A. 二进制文件
B. 纯文本文件
C. 随机存取文件
D. 顺序存取文件

答案：B

### 12
【    】的函数不适合声明为内联函数。

A. 函数体语句较多
B. 函数体内有函数调用
C. 函数体内有if语句
D. 函数体结构简单

答案：A

### 13
使用下列哪个流格式控制符可设置转换基数为八进制【    】

A. dec
B. oct
C. endl
D. hex

答案：B

### 14
函数模板的定义以关键字【    】开头。

A. typename
B. class
C. template
D. include

答案：C

### 15
在一般情况下，将类的成员变量声明为【    】

A. 保护的
B. 通用的
C. 公有的
D. 私有的

答案：D

### 16
下列关于基类与派生类指针的互相转换的说法中，错误的是【    】

A. 如果基类指针指向的是一个派生类的对象，则可以通过基类指针访问基类中没有而仅在派生类中定义的成员函数
B. 对于指针类型，可以使用基类指针指向派生对象，也可以将派生类的指针直接赋值给基类指针
C. 派生类对象组成的集合通常包含在基类对象组成的集合中
D. 基类对象很可能不是派生类对象

答案：A

### 17
下列关于函数参数的默认值的说法中，错误的是【    】

A. 在C++语言中，指定默认值时可以用常数
B. 在C++语言中，可以在声明函数时为形参指定默认值
C. 在C++语言中，可以用任何有定义的表达式作为参数的默认值
D. 在C++语言中，提供默认值时可以按从左至右的顺序提供

答案：D

### 18
当类的继承方式为私有继承时，基类的私有成员在第二级派生类中【    】

A. 调用私有函数访问
B. 不可访问
C. 直接访问
D. 调用公有函数访问

答案：B

### 19
能够直接被计算机识别的是【    】

A. 高级语言
B. 机器语言
C. 汇编语言
D. 中级语言

答案：B

### 20
下面声明纯虚函数语句正确的是【    】

A. virtual void fun();
B. virtual void fun()11;
C. void fun()=0;
D. virtual void fun()=0;

答案：D

### 21
C++程序中的语句必须以【    】结束。

A. 句号
B. 空格
C. 分号
D. 冒号

答案：C

### 22
声明函数模板的关键字是【    】

A. inline
B. short
C. const
D. template

答案：D

### 23
从逻辑关系上看，典型的C++程序的结构不包括【    】

A. 类中成员函数的实现
B. 类的定义
C. 主函数 main
D. 对象的定义

答案：D

### 24
下列关于抽象和封装的说法中，错误的是【    】

A. 抽象不是去了解和描述问题的全部，而只是选择其中相关的一部分
B. 封装和信息隐藏并不能保证对数据的修改仅仅来自于类的内部
C. 封装保证了对象具有较好的独立性
D. 封装就是把对象的属性和操作结合成一个独立的系统单位

答案：B

### 25
当使用输入流类定义一个流对象并打开一个磁盘文件时，文件的隐含打开方式是【    】

A. ios::out
B. ios::in
C. ios::trunc
D. ios::binary

答案：B

### 26
使用已有类编写新的类的方式有【    】

A. 联结
B. 封装
C. 多态
D. 组合

答案：D

### 27
以下关于抽象类的描述正确的是【    】

A. 不能说明指向抽象类对象的指针或引用
B. 可以说明抽象类对象
C. 抽象类的纯虚函数的实现可以由自身给出，也可以由派生类给出
D. 抽象类的纯虚函数的实现由派生类给出

答案：D

### 28
下列关于多层次的派生的说法中，错误的是【    】

A. 在C++中，类之间的继承关系具有独立性
B. 在C++中，派生可以是多层次的
C. 在定义派生类时，只需写直接基类，不需写间接基类
D. 在C++中，类之间的继承关系具有传递性

答案：A

### 30
关闭文件应使用fstream的成员函数【    】

A. outFile()
B. close()
C. inFile()
D. open()

答案：B

### 31
C++中定义标准输入的库为【    】

A. math
B. stdio
C. stdlib
D. istream

答案：D

### 32
在C++中，封装是借助【    】达到的。

A. 数组
B. 结构
C. 类
D. 函数

答案：C

### 33
this 指针是C++实现【    】的一种机制。

A. 多态
B. 封装
C. 继承
D. 高效率

答案：B

### 34
实现两个相同类型数加法的函数模板的声明是【    】

A. T add(x,y)
B. T add(T x,T y)
C. add(T x,T y)
D. T add(T x,y)

答案：B

### 35
下列关于结构化程序设计方法的说法中，错误的是【    】

A. 结构化程序设计方法又称为面向过程的设计方法
B. 结构化程序设计方法注重程序的易读性、可靠性及可维护性
C. 结构化程序设计语言的代表是C++语言和Pascal语言
D. 结构化程序设计方法强调数据类型和程序结构

答案：C

### 36
【】是面向用户的语言，在形式上接近于算数语言和自然语言。 
 
A.高级语言 
B.机器语言 
C.中级语言
D.汇编语言

答案：C 高级语言


### 37
设类M将其他类对象作为成员，则创建类M的对象时，应：
 
A.同时执行类M和成员对象的析构函数
B.同时执行类M和成员对象的构造函数
C.先执行成员对象的构造函数
D.先执行类M的构造函数。

答案：C 先执行成员对象的构造函数

### 38
关于内联函数说法错误的是:
 
A.内联函数中执行代码不能太多
B.内联函数的结构越复杂越好
C.使用内联函数减少调用开销
D.使用内联函数加快了程序执行速度

答案：B

### 39 
在结构化程序设计中，程序的基本控制结构不包括

A.循环
B.顺序
C.递归
D.选择 

答案：C
